[
["nasas-earth-observing-system-eos.html", "Chapter 6 NASA’s Earth Observing System (EOS) 6.1 Learning Objectives 6.2 NASA EOS Project Mission &amp; Design 6.3 NASA EOS Earth Data Account: 6.4 NASA EOS Coding Assignment 1 6.5 Distributed Active Archive Centers 6.6 The LPDAAC Mission: Process, Archive, Distribute, Apply 6.7 AppEEARS 6.8 Hands on: Pulling AppEEARS Data via the API 6.9 Getting Started with the AppEEARS API (Point Request) 6.10 Topics Covered in this section: 6.11 Getting Started with the AppEEARS API 6.12 Query Available Products 6.13 Search and Explore Available Products 6.14 Search and Explore Available Layers 6.15 Submit a Point Request 6.16 Download a Request 6.17 Download Files in a Request (Automation) 6.18 Explore AppEEARS Quality Service 6.19 Decode Quality Values 6.20 Load Request Output and Visualize 6.21 Load a CSV 6.22 Plot Results (Line/Scatter Plots) 6.23 Submit an Area Request 6.24 NASA EOS Written Questions 6.25 NASA EOS Culmination Write Up", " Chapter 6 NASA’s Earth Observing System (EOS) Estimated Time: 3 hours 6.1 Learning Objectives Describe the mission of NASA EOS Describe the roles of DAACs in distributing data Interact with the AppEEARS API to query the list of available products Submit and download submitting a point and area sample requests, download the request Filter data based on quality 6.2 NASA EOS Project Mission &amp; Design NASA’s Earth Observing System (EOS) is a coordinated series of polar-orbiting and low inclination satellites for long-term global observations of the land surface, biosphere, solid Earth, atmosphere, and oceans. As a major component of the Earth Science Division of NASA’s Science Mission Directorate, EOS enables an improved understanding of the Earth as an integrated system. Review NASA EOS’s Mission Profile Completeed Missions Current Missions Future Missions Credit: NASA’s Goddard Space Flight Center 6.3 NASA EOS Earth Data Account: The EOSDIS Earthdata Login provides a centralized and simplified mechanism for user registration and profile management for all EOSDIS system components. End users may register and edit their profile information in one location allowing them access to the wide array of EOSDIS data and services. The EOSDIS Earthdata Login also helps the EOSDIS program better understand the user demographics and access patterns in support of planning for new value-added features and customized services that can be directed to specific users or user groups resulting in better user experience. Earthdata Login provides user registration and authentication services and a common set of user information to all EOSDIS data centers in a manner that permits the data center to integrate their additional requirements with the Earthdata Login services. Below is a brief description of services provided by the Earthdata Login. 6.4 NASA EOS Coding Assignment 1 Suggested completion: following lecture 1 on NASA EOS To submit via BBLearn: 1) Follow the steps in the NASA EOSDIS documentation to sign up for an Earth Data account. Write an R script that stores your user and password called EARTHDATA_Token.R and submit the following line of code via .Rmd and PDF: source(&#39;./Tokens/EARTHDATA_Token.R&#39;) #path will change based on where you stored it exists(&#39;user&#39;) 6.5 Distributed Active Archive Centers 6.5.1 LP DAAC The Land Processes Distributed Active Archive Center (LP DAAC) is one of several discipline-specific data centers within the NASA EOS Data and Information System (EOSDIS). The LP DAAC operates as a partnership between the U.S. Geological Survey (USGS) and the National Aeronautics and Space Administration (NASA). Data specialists, system engineers, user service representatives, and science communicators work in collaboration to support LP DAAC activities. Watch this 4:02 minute video on LP DAAC’s 2019-2021 Prosectus 6.6 The LPDAAC Mission: Process, Archive, Distribute, Apply The LP DAAC processes, archives, and distributes land data products to hundreds of thousands of users in the earth science community. Land data products are made universally accessible and support the ongoing monitoring of Earth’s land dynamics and environmental systems to facilitate interdisciplinary research, education, and decision-making. Process: Raw data collected from specific satellite sensors, such as ASTER onboard NASA’s Terra satellite, are received and processed into a readable and interpretable format here at the LP DAAC, while other data undergo processing in other facilities around the country before arriving to the LP DAAC to be archived and distributed to the public. Archive: The LP DAAC continually archives a wide variety of land remote sensing data products collected by sensors onboard satellites, aircraft, and the International Space Station (ISS). The archive currently totals more than 3.5 petabytes of data, the equivalent of listening to 800 million songs, and distributes data to over 200,000 global users. Distribute: All data products in the archive are distributed free of charge through NASA Earthdata Search and USGS EarthExplorer search and download clients. The LP DAAC also supports tools and services, like the Application for Extracting and Exploring Analysis Ready Samples (AppEEARS), which allows users to transform and visualize data before download while offering enhanced subsetting and reprojecting capabilities. 6.6.1 How you can use LP DAAC’s data Watch this 2:13 minute long video on searching for data at the LP DAAC 6.7 AppEEARS The Application for Extracting and Exploring Analysis Ready Samples (AppEEARS) offers a simple and efficient way to access and transform geospatial data from a variety of federal data archives in an easy-to-use web application interface. AppEEARS enables users to subset geospatial data spatially, temporally, and by band/layer for point and area samples. AppEEARS returns not only the requested data, but also the associated quality values, and offers interactive visualizations with summary statistics in the web interface. The AppEEARS API offers users programmatic access to all features available in AppEEARS, with the exception of visualizations. The API features are demonstrated in this tutorial. 6.8 Hands on: Pulling AppEEARS Data via the API The following section was adapted from LPDAAC’s E-Learning Tutorials on the AppEEARS API and modified to request data for NEON sites. Contributing Authors: Material written by Mahsa Jami1 and Cole Krehbiel1 Contact: LPDAAC@usgs.gov Voice: +1-866-573-3222 Organization: Land Processes Distributed Active Archive Center (LP DAAC) Website: https://lpdaac.usgs.gov/ Date last modified: 06-12-2020 1 KBR, Inc., contractor to the U.S. Geological Survey, Earth Resources Observation and Science (EROS) Center, Sioux Falls, South Dakota, USA. Work performed under USGS contract G15PD00467 for LP DAAC2. 2 LP DAAC Work performed under NASA contract NNG14HH33I. Run the following chunk to install any packages you will need for this section: # Packages you will need for AppEEARS API Tutorials packages = c(&#39;getPass&#39;,&#39;httr&#39;,&#39;jsonlite&#39;,&#39;ggplot2&#39;,&#39;dplyr&#39;,&#39;tidyr&#39;,&#39;readr&#39;,&#39;geojsonio&#39;,&#39;geojsonR&#39;,&#39;rgdal&#39;,&#39;sp&#39;, &#39;raster&#39;, &#39;rasterVis&#39;, &#39;RColorBrewer&#39;, &#39;jsonlite&#39;) # Identify missing packages new.packages = packages[!(packages %in% installed.packages()[,&quot;Package&quot;])] # Loop through and download the required packages if (length(new.packages)[1]==0){ message(&#39;All packages already installed&#39;) }else{ for (i in 1:length(new.packages)){ message(paste0(&#39;Installing: &#39;, new.packages)) install.packages(new.packages[i]) } } 6.9 Getting Started with the AppEEARS API (Point Request) This section demonstrates how to use R to connect to the AppEEARS API The Application for Extracting and Exploring Analysis Ready Samples (AppEEARS) offers a simple and efficient way to access and transform geospatial data from a variety of federal data archives in an easy-to-use web application interface. AppEEARS enables users to subset geospatial data spatially, temporally, and by band/layer for point and area samples. AppEEARS returns not only the requested data, but also the associated quality values, and offers interactive visualizations with summary statistics in the web interface. The AppEEARS API offers users programmatic access to all features available in AppEEARS, with the exception of visualizations. The API features are demonstrated in this tutorial. 6.9.1 Example: Submit a point request for multiple NEON sites to extract vegetation and land surface temperature data In this tutorial, Connecting to the AppEEARS API, querying the list of available products, submitting a point sample request, downloading the request, working with the AppEEARS Quality API, and loading the results into R for visualization are covered. AppEEARS point requests allow users to subset their desired data using latitude/longitude geographic coordinate pairs (points) for a time period of interest, and for specific data layers within data products. AppEEARS returns the valid data from the parameters defined within the sample request. 6.9.1.1 Data Used in the Example: Data layers: Combined MODIS Leaf Area Index (LAI) MCD15A3H.006, 500m, 4 day: ‘Lai_500m’ Terra MODIS Land Surface Temperature MOD11A2.006, 1000m, 8 day: ‘LST_Day_1km’, ‘LST_Night_1km’ 6.10 Topics Covered in this section: Getting Started 1a. Load Packages 1b. Set Up the Output Directory 1c. Login Query Available Products 2a. Search and Explore Available Products 2b. Search and Explore Available Layers Submit a Point Request 3a. Compile a JSON Object 3b. Submit a Task Request 3c. Retrieve Task Status Download a Request 4a. Explore Files in Request Output 4b. Download Files in a Request (Automation) Explore AppEEARS Quality API 5a. List Quality Layers 5b. Show Quality Values 5c. Decode Quality Values BONUS: Load Request Output and Visualize 6a. Load CSV 6b. Plot Results (Line/Scatter Plots) 6.10.1 Prerequisites: A NASA Earthdata Login account is required to login to the AppEEARS API and submit a request . You can create an account at the link provided. R and RStudio. These tutorials have been tested on Windows and MAC systems using R Version 4.0.0, RStudio version 1.1.463, and the specifications listed below. Required packages: getPass httr jsonlite warnings To read and visualize the tabular data: dplyr tidyr readr ggplot2 6.10.1.1 Getting Started: Clone/download AppEEARS API Getting Started in R Repository from the LP DAAC Data User Resources Repository or pull code from this textbook. If you opted to clone LP DAAC’s repo open the AppEEARS_API_R.Rproj file to directly open the project. Next, select the AppEEARS_API_Point_R.Rmd from the files list and open it. 6.10.2 AppEEARS Information: To access AppEEARS, visit: https://lpdaacsvc.cr.usgs.gov/appeears/. For comprehensive documentation of the full functionality of the AppEEARS API, please see the AppEEARS API Documentation. 6.11 Getting Started with the AppEEARS API 6.11.1 Load Packages First, load the R packages necessary to run the tutorial. # Load necessary packages into R library(getPass) # A micro-package for reading passwords library(httr) # To send a request to the server/receive a response from the server library(jsonlite) # Implements a bidirectional mapping between JSON data and the most important R data types library(ggplot2) # Functions for graphing and mapping library(tidyr) # Function for working with tabular data library(dplyr) # Function for working with tabular data library(readr) # Read rectangular data like CSV 6.11.2 Set Up the Output Directory Set your input directory, and create an output directory for the results. outDir &lt;- file.path(&#39;./data/&#39;) # Create an output directory if it doesn&#39;t exist suppressWarnings(dir.create(outDir)) 6.11.3 Login to Earth Data To submit a request, you must first login to the AppEEARS API. Use your private R Script to enter your NASA Earthdata login Username and Password. source(&#39;./Tokens/EARTHDATA_Token.R&#39;) #path will change based on where you stored it exists(&#39;user&#39;) ## [1] TRUE Decode the username and password to be used to post login request. secret &lt;- jsonlite::base64_enc(paste(user, password, sep = &quot;:&quot;)) # Encode the string of username and password Next, assign the AppEEARS API URL to a static variable. API_URL = &#39;https://lpdaacsvc.cr.usgs.gov/appeears/api/&#39; # Set the AppEEARS API to a variable Use the httr package to post your username and password. A successful login will provide you with a token to be used later in this tutorial to submit a request. For more information or if you are experiencing difficulties, please see the API Documentation. # Insert API URL, call login service, set the component of HTTP header, and post the request to the server response &lt;- httr::POST(paste0(API_URL,&quot;login&quot;), add_headers(&quot;Authorization&quot; = paste(&quot;Basic&quot;, gsub(&quot;\\n&quot;, &quot;&quot;, secret)), &quot;Content-Type&quot; =&quot;application/x-www-form-urlencoded;charset=UTF-8&quot;), body = &quot;grant_type=client_credentials&quot;) response_content &lt;- content(response) # Retrieve the content of the request token_response &lt;- toJSON(response_content, auto_unbox = TRUE) # Convert the response to the JSON object remove(user, password, secret, response) # Remove the variables that are not needed anymore prettify(token_response) # Print the prettified response ## { ## &quot;token_type&quot;: &quot;Bearer&quot;, ## &quot;token&quot;: &quot;dZBdb-Pn7AdlNi8uxzWpWbTAK_6M-H6PBKKmm5DOOvnb-GI-6TFM5c-e_48CkPJyM71fWQ3MbRb9Dx7hNwD8QA&quot;, ## &quot;expiration&quot;: &quot;2020-10-09T20:33:11Z&quot; ## } ## Above, you should see a Bearer token. Notice that this token will expire approximately 48 hours after being acquired. 6.12 Query Available Products The product API provides details about all of the products and layers available in AppEEARS. For more information, please see the API Documentation. Below, call the product API to list all of the products available in AppEEARS. prods_req &lt;- GET(paste0(API_URL, &quot;product&quot;)) # Request the info of all products from product service prods_content &lt;- content(prods_req) # Retrieve the content of request all_Prods &lt;- toJSON(prods_content, auto_unbox = TRUE) # Convert the info to JSON object remove(prods_req, prods_content) # Remove the variables that are not needed anymore # prettify(all_Prods) # Print the prettified product response 6.13 Search and Explore Available Products Create a list indexed by product name to make it easier to query a specific product. # Divides information from each product. divided_products &lt;- split(fromJSON(all_Prods), seq(nrow(fromJSON(all_Prods)))) # Create a list indexed by the product name and version products &lt;- setNames(divided_products,fromJSON(all_Prods)$ProductAndVersion) # Print no. products available in AppEEARS sprintf(&quot;AppEEARS currently supports %i products.&quot; ,length(products)) ## [1] &quot;AppEEARS currently supports 120 products.&quot; Next, look at the product’s names and descriptions. Below, the ‘ProductAndVersion’ and ‘Description’ are printed for all products. # Loop through the products in the list and print the product name and description for (p in products){ print(paste0(p$ProductAndVersion,&quot; is &quot;,p$Description,&quot; from &quot;,p$Source)) } ## [1] &quot;GPW_DataQualityInd.004 is Quality of Input Data for Population Count and Density Grids from SEDAC&quot; ## [1] &quot;GPW_UN_Adj_PopCount.004 is UN-adjusted Population Count from SEDAC&quot; ## [1] &quot;GPW_UN_Adj_PopDensity.004 is UN-adjusted Population Density from SEDAC&quot; ## [1] &quot;MCD12Q1.006 is Land Cover Type from LP DAAC&quot; ## [1] &quot;MCD12Q2.006 is Land Cover Dynamics from LP DAAC&quot; ## [1] &quot;MCD15A2H.006 is Leaf Area Index (LAI) and Fraction of Photosynthetically Active Radiation (FPAR) from LP DAAC&quot; ## [1] &quot;MCD15A3H.006 is Leaf Area Index (LAI) and Fraction of Photosynthetically Active Radiation (FPAR) from LP DAAC&quot; ## [1] &quot;MCD43A1.006 is Bidirectional Reflectance Distribution Function (BRDF) and Albedo from LP DAAC&quot; ## [1] &quot;MCD43A3.006 is Bidirectional Reflectance Distribution Function (BRDF) and Albedo from LP DAAC&quot; ## [1] &quot;MCD43A4.006 is Bidirectional Reflectance Distribution Function (BRDF) and Albedo from LP DAAC&quot; ## [1] &quot;MCD64A1.006 is Thermal Anomalies and Fire from LP DAAC&quot; ## [1] &quot;MOD09A1.006 is Surface Reflectance Bands 1-7 from LP DAAC&quot; ## [1] &quot;MOD09GA.006 is Surface Reflectance Bands 1-7 from LP DAAC&quot; ## [1] &quot;MOD09GQ.006 is Surface Reflectance Bands 1-2 from LP DAAC&quot; ## [1] &quot;MOD09Q1.006 is Surface Reflectance Bands 1-2 from LP DAAC&quot; ## [1] &quot;MOD10A1.005 is Snow Cover from NSIDC DAAC&quot; ## [1] &quot;MOD10A1.006 is Snow Cover from NSIDC DAAC&quot; ## [1] &quot;MOD10A2.005 is Snow Cover from NSIDC DAAC&quot; ## [1] &quot;MOD10A2.006 is Snow Cover from NSIDC DAAC&quot; ## [1] &quot;MOD11A1.006 is Land Surface Temperature &amp; Emissivity (LST&amp;E) from LP DAAC&quot; ## [1] &quot;MOD11A2.006 is Land Surface Temperature &amp; Emissivity (LST&amp;E) from LP DAAC&quot; ## [1] &quot;MOD13A1.006 is Vegetation Indices (NDVI &amp; EVI) from LP DAAC&quot; ## [1] &quot;MOD13A2.006 is Vegetation Indices (NDVI &amp; EVI) from LP DAAC&quot; ## [1] &quot;MOD13A3.006 is Vegetation Indices (NDVI &amp; EVI) from LP DAAC&quot; ## [1] &quot;MOD13Q1.006 is Vegetation Indices (NDVI &amp; EVI) from LP DAAC&quot; ## [1] &quot;MOD14A2.006 is Thermal Anomalies and Fire from LP DAAC&quot; ## [1] &quot;MOD15A2H.006 is Leaf Area Index (LAI) and Fraction of Photosynthetically Active Radiation (FPAR) from LP DAAC&quot; ## [1] &quot;MOD16A2.006 is Evapotranspiration (ET &amp; LE) from LP DAAC&quot; ## [1] &quot;MOD16A2GF.006 is Net Evapotranspiration Gap-Filled (ET &amp; LE) from LP DAAC&quot; ## [1] &quot;MOD16A3GF.006 is Net Evapotranspiration Gap-Filled (ET &amp; LE) from LP DAAC&quot; ## [1] &quot;MOD17A2H.006 is Gross Primary Productivity (GPP) from LP DAAC&quot; ## [1] &quot;MOD17A2HGF.006 is Gross Primary Productivity (GPP) from LP DAAC&quot; ## [1] &quot;MOD17A3HGF.006 is Net Primary Production (NPP) Gap-Filled from LP DAAC&quot; ## [1] &quot;MOD44B.006 is Vegetation Continuous Fields (VCF) from LP DAAC&quot; ## [1] &quot;MOD44W.006 is Land/Water Mask from LP DAAC&quot; ## [1] &quot;MODOCGA.006 is Ocean Reflectance Bands 8-16 from LP DAAC&quot; ## [1] &quot;MODTBGA.006 is Thermal Bands and Albedo from LP DAAC&quot; ## [1] &quot;MYD09A1.006 is Surface Reflectance Bands 1-7 from LP DAAC&quot; ## [1] &quot;MYD09GA.006 is Surface Reflectance Bands 1-7 from LP DAAC&quot; ## [1] &quot;MYD09GQ.006 is Surface Reflectance Bands 1-2 from LP DAAC&quot; ## [1] &quot;MYD09Q1.006 is Surface Reflectance Bands 1-2 from LP DAAC&quot; ## [1] &quot;MYD10A1.005 is Snow Cover from NSIDC DAAC&quot; ## [1] &quot;MYD10A1.006 is Snow Cover from NSIDC DAAC&quot; ## [1] &quot;MYD10A2.005 is Snow Cover from NSIDC DAAC&quot; ## [1] &quot;MYD10A2.006 is Snow Cover from NSIDC DAAC&quot; ## [1] &quot;MYD11A1.006 is Land Surface Temperature &amp; Emissivity (LST&amp;E) from LP DAAC&quot; ## [1] &quot;MYD11A2.006 is Land Surface Temperature &amp; Emissivity (LST&amp;E) from LP DAAC&quot; ## [1] &quot;MYD13A1.006 is Vegetation Indices (NDVI &amp; EVI) from LP DAAC&quot; ## [1] &quot;MYD13A2.006 is Vegetation Indices (NDVI &amp; EVI) from LP DAAC&quot; ## [1] &quot;MYD13A3.006 is Vegetation Indices (NDVI &amp; EVI) from LP DAAC&quot; ## [1] &quot;MYD13Q1.006 is Vegetation Indices (NDVI &amp; EVI) from LP DAAC&quot; ## [1] &quot;MYD14A2.006 is Thermal Anomalies and Fire from LP DAAC&quot; ## [1] &quot;MYD15A2H.006 is Leaf Area Index (LAI) and Fraction of Photosynthetically Active Radiation (FPAR) from LP DAAC&quot; ## [1] &quot;MYD16A2.006 is Evapotranspiration (ET &amp; LE) from LP DAAC&quot; ## [1] &quot;MYD16A2GF.006 is Net Evapotranspiration Gap-Filled (ET &amp; LE) from LP DAAC&quot; ## [1] &quot;MYD16A3GF.006 is Net Evapotranspiration Gap-Filled (ET &amp; LE) from LP DAAC&quot; ## [1] &quot;MYD17A2H.006 is Gross Primary Productivity (GPP) from LP DAAC&quot; ## [1] &quot;MYD17A2HGF.006 is Gross Primary Productivity (GPP) Gap-Filled from LP DAAC&quot; ## [1] &quot;MYD17A3HGF.006 is Net Primary Production (NPP) Gap-Filled from LP DAAC&quot; ## [1] &quot;MYD21A1D.006 is Temperature and Emissivity (LST&amp;E) from LP DAAC&quot; ## [1] &quot;MYD21A1N.006 is Temperature and Emissivity (LST&amp;E) from LP DAAC&quot; ## [1] &quot;MYD21A2.006 is Temperature and Emissivity (LST&amp;E) from LP DAAC&quot; ## [1] &quot;MYDOCGA.006 is Ocean Reflectance Bands 8-16 from LP DAAC&quot; ## [1] &quot;MYDTBGA.006 is Thermal Bands and Albedo from LP DAAC&quot; ## [1] &quot;NASADEM_NC.001 is Elevation from LP DAAC&quot; ## [1] &quot;NASADEM_NUMNC.001 is Source from LP DAAC&quot; ## [1] &quot;SPL3SMP_E.003 is Enhanced L3 Radiometer Soil Moisture from NSIDC DAAC&quot; ## [1] &quot;SPL3SMP.006 is Soil Moisture from NSIDC DAAC&quot; ## [1] &quot;SPL4CMDL.004 is Carbon Net Ecosystem Exchange from NSIDC DAAC&quot; ## [1] &quot;SPL4SMGP.004 is Surface and Root Zone Soil Moisture from NSIDC DAAC&quot; ## [1] &quot;SPL3FTP.002 is Freeze/Thaw State from NSIDC DAAC&quot; ## [1] &quot;SRTMGL1_NC.003 is Elevation from LP DAAC&quot; ## [1] &quot;SRTMGL1_NUMNC.003 is Source from LP DAAC&quot; ## [1] &quot;SRTMGL3_NC.003 is Elevation from LP DAAC&quot; ## [1] &quot;SRTMGL3_NUMNC.003 is Source from LP DAAC&quot; ## [1] &quot;ASTGTM_NC.003 is Elevation from LP DAAC&quot; ## [1] &quot;ASTGTM_NUMNC.003 is Source from LP DAAC&quot; ## [1] &quot;ASTWBD_ATTNC.001 is Water Bodies Database Attributes from LP DAAC&quot; ## [1] &quot;ASTWBD_NC.001 is Water Bodies Database Elevation from LP DAAC&quot; ## [1] &quot;VNP09H1.001 is Surface Reflectance from LP DAAC&quot; ## [1] &quot;VNP09A1.001 is Surface Reflectance from LP DAAC&quot; ## [1] &quot;VNP13A1.001 is Vegetation Indices from LP DAAC&quot; ## [1] &quot;VNP13A2.001 is Vegetation Indices from LP DAAC&quot; ## [1] &quot;VNP13A3.001 is Vegetation Indices from LP DAAC&quot; ## [1] &quot;VNP14A1.001 is Thermal Anomalies/Fire from LP DAAC&quot; ## [1] &quot;VNP15A2H.001 is Leaf Area Index (LAI) and Fraction of Photosynthetically Active Radiation (FPAR) from LP DAAC&quot; ## [1] &quot;VNP21A1D.001 is Land Surface Temperature and Emissivity Day from LP DAAC&quot; ## [1] &quot;VNP21A1N.001 is Land Surface Temperature and Emissivity Night from LP DAAC&quot; ## [1] &quot;VNP21A2.001 is Land Surface Temperature and Emissivity from LP DAAC&quot; ## [1] &quot;VNP43IA1.001 is BRDF-Albedo Model Parameters from LP DAAC&quot; ## [1] &quot;VNP43IA2.001 is BRDF-Albedo Quality from LP DAAC&quot; ## [1] &quot;VNP43IA3.001 is Albedo from LP DAAC&quot; ## [1] &quot;VNP43IA4.001 is Nadir BRDF-Adjusted Reflectance from LP DAAC&quot; ## [1] &quot;VNP43MA1.001 is BRDF-Albedo Model Parameters from LP DAAC&quot; ## [1] &quot;VNP43MA2.001 is BRDF-Albedo Quality from LP DAAC&quot; ## [1] &quot;VNP43MA3.001 is Albedo from LP DAAC&quot; ## [1] &quot;VNP43MA4.001 is Nadir BRDF-Adjusted Reflectance from LP DAAC&quot; ## [1] &quot;CU_LC08.001 is Landsat 8 Surface Reflectance from USGS&quot; ## [1] &quot;CU_LE07.001 is Landsat 7 Surface Reflectance from USGS&quot; ## [1] &quot;CU_LT05.001 is Landsat 5 Surface Reflectance from USGS&quot; ## [1] &quot;CU_LT04.001 is Landsat 4 Surface Reflectance from USGS&quot; ## [1] &quot;AK_LC08.001 is Alaska Landsat 8 Surface Reflectance from USGS&quot; ## [1] &quot;AK_LE07.001 is Alaska Landsat 7 Surface Reflectance from USGS&quot; ## [1] &quot;AK_LT05.001 is Alaska Landsat 5 Surface Reflectance from USGS&quot; ## [1] &quot;AK_LT04.001 is Alaska Landsat 4 Surface Reflectance from USGS&quot; ## [1] &quot;HI_LC08.001 is Hawaii Landsat 8 Surface Reflectance from USGS&quot; ## [1] &quot;HI_LE07.001 is Hawaii Landsat 7 Surface Reflectance from USGS&quot; ## [1] &quot;HI_LT05.001 is Hawaii Landsat 5 Surface Reflectance from USGS&quot; ## [1] &quot;HI_LT04.001 is Hawaii Landsat 4 Surface Reflectance from USGS&quot; ## [1] &quot;DAYMET.003 is Daily Surface Weather Data for North America from ORNL&quot; ## [1] &quot;SSEBop_ET.004 is SSEBop Actual Evapotranspiration (ETa) from USGS&quot; ## [1] &quot;eMODIS_Smoothed_NDVI.001 is eMODIS Smoothed Normalized Difference Vegetation Index (NDVI) from USGS&quot; ## [1] &quot;ECO2LSTE.001 is Land Surface Temperature &amp; Emissivity (LST&amp;E) from LP DAAC&quot; ## [1] &quot;ECO2CLD.001 is Cloud Mask from LP DAAC&quot; ## [1] &quot;ECO3ETPTJPL.001 is Evapotranspiration PT-JPL from LP DAAC&quot; ## [1] &quot;ECO3ANCQA.001 is L3/L4 Ancillary Data Quality Assurance (QA) Flags from LP DAAC&quot; ## [1] &quot;ECO4ESIPTJPL.001 is Evaporative Stress Index PT-JPL from LP DAAC&quot; ## [1] &quot;ECO4WUE.001 is Water Use Efficiency from LP DAAC&quot; ## [1] &quot;ECO1BGEO.001 is Geolocation from LP DAAC&quot; ## [1] &quot;ECO1BMAPRAD.001 is Resampled Radiance from LP DAAC&quot; The product service provides many useful details, including if a product is currently available in AppEEARS, a description, and information on the spatial and temporal resolution. Below, the product details are retrieved using ‘ProductAndVersion’. # Convert the MCD15A3H.006 info to JSON object and print the prettified info prettify(toJSON(products$&quot;MCD15A3H.006&quot;)) ## [ ## { ## &quot;Product&quot;: &quot;MCD15A3H&quot;, ## &quot;Platform&quot;: &quot;Combined MODIS&quot;, ## &quot;Description&quot;: &quot;Leaf Area Index (LAI) and Fraction of Photosynthetically Active Radiation (FPAR)&quot;, ## &quot;RasterType&quot;: &quot;Tile&quot;, ## &quot;Resolution&quot;: &quot;500m&quot;, ## &quot;TemporalGranularity&quot;: &quot;4 day&quot;, ## &quot;Version&quot;: &quot;006&quot;, ## &quot;Available&quot;: true, ## &quot;DocLink&quot;: &quot;https://doi.org/10.5067/MODIS/MCD15A3H.006&quot;, ## &quot;Source&quot;: &quot;LP DAAC&quot;, ## &quot;TemporalExtentStart&quot;: &quot;2002-07-04&quot;, ## &quot;TemporalExtentEnd&quot;: &quot;Present&quot;, ## &quot;Deleted&quot;: false, ## &quot;DOI&quot;: &quot;10.5067/MODIS/MCD15A3H.006&quot;, ## &quot;ProductAndVersion&quot;: &quot;MCD15A3H.006&quot; ## } ## ] ## Also, the products can be searched using their description. Below, search for products containing Leaf Area Index in their description and make a list of their productAndVersion. LAI_Products &lt;- list() # Create an empty list for (p in products){ # Loop through the product list if (grepl(&#39;Leaf Area Index&#39;, p$Description )){ # Look through the product description for a keyword LAI_Products &lt;- append(LAI_Products, p$ProductAndVersion) # Append the LAI products to the list } } LAI_Products ## [[1]] ## [1] &quot;MCD15A2H.006&quot; ## ## [[2]] ## [1] &quot;MCD15A3H.006&quot; ## ## [[3]] ## [1] &quot;MOD15A2H.006&quot; ## ## [[4]] ## [1] &quot;MYD15A2H.006&quot; ## ## [[5]] ## [1] &quot;VNP15A2H.001&quot; Using the info above, Create a list of desired products. desired_products &lt;- c(&#39;MCD15A3H.006&#39;,&#39;MOD11A2.006&#39;) # Create a vector of desired products desired_products ## [1] &quot;MCD15A3H.006&quot; &quot;MOD11A2.006&quot; 6.14 Search and Explore Available Layers This API call will list all of the layers available for a given product. Each product is referenced by its ProductAndVersion property which is also referred to as the product_id. First, request the layers for the MCD15A3H.006 product. # Request layers for the 1st product in the list: MCD15A3H.006 MCD15A3H_req &lt;- GET(paste0(API_URL,&quot;product/&quot;, desired_products[1])) # Request the info of a product from product URL MCD15A3H_content &lt;- content(MCD15A3H_req) # Retrieve content of the request MCD15A3H_response &lt;- toJSON(MCD15A3H_content, auto_unbox = TRUE) # Convert the content to JSON object remove(MCD15A3H_req, MCD15A3H_content) # Remove the variables that are not needed anymore #prettify(MCD15A3H_response) # Print the prettified response names(fromJSON(MCD15A3H_response)) # print the layer&#39;s names ## [1] &quot;FparExtra_QC&quot; &quot;FparLai_QC&quot; &quot;FparStdDev_500m&quot; &quot;Fpar_500m&quot; ## [5] &quot;LaiStdDev_500m&quot; &quot;Lai_500m&quot; Next, request the layers for the MOD11A2.006 product. MOD11_req &lt;- GET(paste0(API_URL,&quot;product/&quot;, desired_products[2])) # Request the info of a product from product URL MOD11_content &lt;- content(MOD11_req) # Retrieve content of the request MOD11_response &lt;- toJSON(MOD11_content, auto_unbox = TRUE) # Convert the content to JSON object remove(MOD11_req, MOD11_content) # Remove the variables that are not needed anymore names(fromJSON(MOD11_response)) # print the layer names ## [1] &quot;Clear_sky_days&quot; &quot;Clear_sky_nights&quot; &quot;Day_view_angl&quot; &quot;Day_view_time&quot; ## [5] &quot;Emis_31&quot; &quot;Emis_32&quot; &quot;LST_Day_1km&quot; &quot;LST_Night_1km&quot; ## [9] &quot;Night_view_angl&quot; &quot;Night_view_time&quot; &quot;QC_Day&quot; &quot;QC_Night&quot; Lastly, select the desired layers and pertinent products and make a data frame using this information. This data frame will be inserted into the nested data frame that will be used to create a JSON object to submit a request in Section 3. desired_layers &lt;- c(&quot;LST_Day_1km&quot;,&quot;LST_Night_1km&quot;,&quot;Lai_500m&quot;) # Create a vector of desired layers desired_prods &lt;- c(&quot;MOD11A2.006&quot;,&quot;MOD11A2.006&quot;,&quot;MCD15A3H.006&quot;) # Create a vector of products including the desired layers # Create a data frame including the desired data products and layers layers &lt;- data.frame(product = desired_prods, layer = desired_layers) 6.15 Submit a Point Request The Submit task API call provides a way to submit a new request to be processed. It can accept data via JSON or query string. In the example below, create a JSON object and submit a request. Tasks in AppEEARS correspond to each request associated with your user account. Therefore, each of the calls to this service requires an authentication token (see Section 1c.). 6.15.1 Compile a JSON Object In this section, begin by setting up the information needed for a nested data frame that will be later converted to a JSON object for submitting an AppEEARS point request. For detailed information on required JSON parameters, see the API Documentation. For point requests, beside the date range and desired layers information, the coordinates property must also be inside the task object. Optionally, set id and category properties to further identify your selected coordinates. We’ll start by requesting point-based data for NEON.D17.SOAP and NEON.D17.SJER: startDate &lt;- &quot;01-01-2020&quot; # Start of the date range for which to extract data: MM-DD-YYYY endDate &lt;- &quot;10-01-2020&quot; # End of the date range for which to extract data: MM-DD-YYYY recurring &lt;- FALSE # Specify True for a recurring date range #yearRange &lt;- [2000,2016] # If recurring = True, set yearRange, change start/end date to MM-DD lat &lt;- c(37.0334, 37.1088) # Latitude of the point sites lon &lt;- c(-119.2622, -119.7323) # Longitude of the point sites id &lt;- c(&quot;0&quot;,&quot;1&quot;) # ID for the point sites category &lt;- c(&quot;SOAP&quot;, &quot;SJER&quot;) # Category for point sites taskName &lt;- &#39;NEON SOAP SJER Vegetation&#39; # Enter name of the task here taskType &lt;- &#39;point&#39; # Specify the task type, it can be either &quot;area&quot; or &quot;point&quot; To be able to successfully submit a task, the JSON object should be structured in a certain way. The code chunk below uses the information from the previous chunk to create a nested data frame. This nested data frame will be converted to JSON object that can be used to complete the request. # Create a data frame including the date range for the request date &lt;- data.frame(startDate = startDate, endDate = endDate) # Create a data frame including lat and long coordinates. ID and category name is optional. coordinates &lt;- data.frame(id = id, longitude = lon, latitude = lat, category = category) task_info &lt;- list(date,layers, coordinates) # Create a list of data frames names(task_info) &lt;- c(&quot;dates&quot;, &quot;layers&quot;, &quot;coordinates&quot;) # Assign names task &lt;- list(task_info, taskName, taskType) # Create a nested list names(task) &lt;- c(&quot;params&quot;, &quot;task_name&quot;, &quot;task_type&quot;) # Assign names remove(date, layers, coordinates, task_info) # Remove the variables that are not needed anymore toJSON function from jsonlite package converts the type of data frame to a string that can be recognized as a JSON object to be submitted as a point request. task_json &lt;- toJSON(task,auto_unbox = TRUE) # Convert to JSON object 6.15.2 Submit a Task Request Token information is needed to submit a request. Below the login token is assigned to a variable. token &lt;- paste(&quot;Bearer&quot;, fromJSON(token_response)$token) # Save login token to a variable Below, post a call to the API task service, using the task_json created above. # Post the point request to the API task service response &lt;- POST(paste0(API_URL, &quot;task&quot;), body = task_json , encode = &quot;json&quot;, add_headers(Authorization = token, &quot;Content-Type&quot; = &quot;application/json&quot;)) task_content &lt;- content(response) # Retrieve content of the request task_response &lt;- prettify(toJSON(task_content, auto_unbox = TRUE))# Convert the content to JSON object remove(response, task_content) # Remove the variables that are not needed anymore task_response # Print the prettified task response ## { ## &quot;task_id&quot;: &quot;3a808dfa-ff0b-48f9-ac7b-9f598d73233b&quot;, ## &quot;status&quot;: &quot;pending&quot; ## } ## 6.15.3 Retrieve Task Status This API call will list all of the requests associated with your user account, automatically sorted by date descending with the most recent requests listed first. The AppEEARS API contains some helpful formatting resources. Below, limit the API response to 2 entries for the last 2 requests and set pretty to True to format the response as an organized JSON object to make it easier to read. Additional information on AppEEARS API retrieve task, pagination, and formatting can be found in the API documentation. params &lt;- list(limit = 2, pretty = TRUE) # Set up query parameters # Request the task status of last 2 requests from task URL response_req &lt;- GET(paste0(API_URL,&quot;task&quot;), query = params, add_headers(Authorization = token)) response_content &lt;- content(response_req) # Retrieve content of the request status_response &lt;- toJSON(response_content, auto_unbox = TRUE) # Convert the content to JSON object remove(response_req, response_content) # Remove the variables that are not needed anymore prettify(status_response) # Print the prettified response ## [ ## { ## &quot;params&quot;: { ## &quot;dates&quot;: [ ## { ## &quot;endDate&quot;: &quot;10-01-2020&quot;, ## &quot;startDate&quot;: &quot;01-01-2020&quot; ## } ## ], ## &quot;layers&quot;: [ ## { ## &quot;layer&quot;: &quot;LST_Day_1km&quot;, ## &quot;product&quot;: &quot;MOD11A2.006&quot; ## }, ## { ## &quot;layer&quot;: &quot;LST_Night_1km&quot;, ## &quot;product&quot;: &quot;MOD11A2.006&quot; ## }, ## { ## &quot;layer&quot;: &quot;Lai_500m&quot;, ## &quot;product&quot;: &quot;MCD15A3H.006&quot; ## } ## ] ## }, ## &quot;status&quot;: &quot;pending&quot;, ## &quot;created&quot;: &quot;2020-10-07T21:37:14.871259&quot;, ## &quot;task_id&quot;: &quot;3a808dfa-ff0b-48f9-ac7b-9f598d73233b&quot;, ## &quot;updated&quot;: &quot;2020-10-07T21:37:14.883937&quot;, ## &quot;user_id&quot;: &quot;kdw223@nau.edu&quot;, ## &quot;estimate&quot;: { ## &quot;request_size&quot;: 204 ## }, ## &quot;task_name&quot;: &quot;NEON SOAP SJER Vegetation&quot;, ## &quot;task_type&quot;: &quot;point&quot;, ## &quot;api_version&quot;: &quot;v1&quot;, ## &quot;svc_version&quot;: &quot;2.47&quot;, ## &quot;web_version&quot;: { ## ## }, ## &quot;expires_on&quot;: &quot;2020-11-06T21:37:14.883937&quot; ## }, ## { ## &quot;error&quot;: { ## ## }, ## &quot;params&quot;: { ## &quot;dates&quot;: [ ## { ## &quot;endDate&quot;: &quot;10-01-2020&quot;, ## &quot;startDate&quot;: &quot;01-01-2020&quot; ## } ## ], ## &quot;layers&quot;: [ ## { ## &quot;layer&quot;: &quot;LST_Day_1km&quot;, ## &quot;product&quot;: &quot;MOD11A2.006&quot; ## }, ## { ## &quot;layer&quot;: &quot;LST_Night_1km&quot;, ## &quot;product&quot;: &quot;MOD11A2.006&quot; ## }, ## { ## &quot;layer&quot;: &quot;Lai_500m&quot;, ## &quot;product&quot;: &quot;MCD15A3H.006&quot; ## } ## ] ## }, ## &quot;status&quot;: &quot;done&quot;, ## &quot;created&quot;: &quot;2020-10-07T21:00:20.497312&quot;, ## &quot;task_id&quot;: &quot;de45360e-d6e4-4577-97a1-760b9893c002&quot;, ## &quot;updated&quot;: &quot;2020-10-07T21:02:10.990738&quot;, ## &quot;user_id&quot;: &quot;kdw223@nau.edu&quot;, ## &quot;attempts&quot;: 1, ## &quot;estimate&quot;: { ## &quot;request_size&quot;: 204 ## }, ## &quot;retry_at&quot;: { ## ## }, ## &quot;completed&quot;: &quot;2020-10-07T21:02:10.987115&quot;, ## &quot;task_name&quot;: &quot;NEON SOAP SJER Vegetation&quot;, ## &quot;task_type&quot;: &quot;point&quot;, ## &quot;api_version&quot;: &quot;v1&quot;, ## &quot;svc_version&quot;: &quot;2.47&quot;, ## &quot;web_version&quot;: { ## ## }, ## &quot;size_category&quot;: &quot;0&quot;, ## &quot;expires_on&quot;: &quot;2020-11-06T21:02:10.990738&quot; ## } ## ] ## The task_id that was generated when submitting your request can also be used to retrieve a task status. task_id &lt;- fromJSON(task_response)$task_id # Extract the task_id of submitted point request # Request the task status of a task with the provided task_id from task URL status_req &lt;- GET(paste0(API_URL,&quot;task/&quot;, task_id), add_headers(Authorization = token)) status_content &lt;- content(status_req) # Retrieve content of the request statusResponse &lt;-toJSON(status_content, auto_unbox = TRUE) # Convert the content to JSON object stat &lt;- fromJSON(statusResponse)$status # Assign the task status to a variable remove(status_req, status_content) # Remove the variables that are not needed anymore prettify(statusResponse) # Print the prettified response ## { ## &quot;params&quot;: { ## &quot;dates&quot;: [ ## { ## &quot;endDate&quot;: &quot;10-01-2020&quot;, ## &quot;startDate&quot;: &quot;01-01-2020&quot; ## } ## ], ## &quot;layers&quot;: [ ## { ## &quot;layer&quot;: &quot;LST_Day_1km&quot;, ## &quot;product&quot;: &quot;MOD11A2.006&quot; ## }, ## { ## &quot;layer&quot;: &quot;LST_Night_1km&quot;, ## &quot;product&quot;: &quot;MOD11A2.006&quot; ## }, ## { ## &quot;layer&quot;: &quot;Lai_500m&quot;, ## &quot;product&quot;: &quot;MCD15A3H.006&quot; ## } ## ], ## &quot;coordinates&quot;: [ ## { ## &quot;id&quot;: &quot;0&quot;, ## &quot;category&quot;: &quot;SOAP&quot;, ## &quot;latitude&quot;: 37.0334, ## &quot;longitude&quot;: -119.2622 ## }, ## { ## &quot;id&quot;: &quot;1&quot;, ## &quot;category&quot;: &quot;SJER&quot;, ## &quot;latitude&quot;: 37.1088, ## &quot;longitude&quot;: -119.7323 ## } ## ] ## }, ## &quot;status&quot;: &quot;pending&quot;, ## &quot;created&quot;: &quot;2020-10-07T21:37:14.871259&quot;, ## &quot;task_id&quot;: &quot;3a808dfa-ff0b-48f9-ac7b-9f598d73233b&quot;, ## &quot;updated&quot;: &quot;2020-10-07T21:37:14.883937&quot;, ## &quot;user_id&quot;: &quot;kdw223@nau.edu&quot;, ## &quot;estimate&quot;: { ## &quot;request_size&quot;: 204 ## }, ## &quot;task_name&quot;: &quot;NEON SOAP SJER Vegetation&quot;, ## &quot;task_type&quot;: &quot;point&quot;, ## &quot;api_version&quot;: &quot;v1&quot;, ## &quot;svc_version&quot;: &quot;2.47&quot;, ## &quot;web_version&quot;: { ## ## }, ## &quot;expires_on&quot;: &quot;2020-11-06T21:37:14.883937&quot; ## } ## Retrieve the task status every 5 seconds. The task status should be done to be able to download the output. while (stat != &#39;done&#39;) { Sys.sleep(5) # Request the task status and retrieve content of request from task URL stat_content &lt;- content(GET(paste0(API_URL,&quot;task/&quot;, task_id), add_headers(Authorization = token))) stat &lt;-fromJSON(toJSON(stat_content, auto_unbox = TRUE))$status # Get the status remove(stat_content) print(stat) } ## [1] &quot;done&quot; 6.16 Download a Request 6.16.1 Explore Files in Request Output Before downloading the request output, examine the files contained in the request output. # Request the task bundle info from API bundle URL response &lt;- GET(paste0(API_URL, &quot;bundle/&quot;, task_id), add_headers(Authorization = token)) response_content &lt;- content(response) # Retrieve content of the request bundle_response &lt;- toJSON(response_content, auto_unbox = TRUE) # Convert the content to JSON object prettify(bundle_response) # Print the prettified response ## { ## &quot;files&quot;: [ ## { ## &quot;sha256&quot;: &quot;e12e3634d11491fd77aa4c8f347b94304885746713852d21a08c635b2a9e4852&quot;, ## &quot;file_id&quot;: &quot;82ab979e-0dbe-4869-b676-88193c79727f&quot;, ## &quot;file_name&quot;: &quot;NEON-SOAP-SJER-Vegetation-MCD15A3H-006-results.csv&quot;, ## &quot;file_size&quot;: 68260, ## &quot;file_type&quot;: &quot;csv&quot; ## }, ## { ## &quot;sha256&quot;: &quot;e465df89151b28d63a1dda2420cedec7f24b383d03e0482083839565a27f8d5d&quot;, ## &quot;file_id&quot;: &quot;ab2e3574-3c50-44dd-bafd-c30b1fb4d99d&quot;, ## &quot;file_name&quot;: &quot;NEON-SOAP-SJER-Vegetation-MOD11A2-006-results.csv&quot;, ## &quot;file_size&quot;: 28570, ## &quot;file_type&quot;: &quot;csv&quot; ## }, ## { ## &quot;sha256&quot;: &quot;100dd40b43760430c900eea1d39b78a73bf880ae397020ad29bcf1c58947e8b5&quot;, ## &quot;file_id&quot;: &quot;765639a0-7278-497d-aca6-433ebf41d021&quot;, ## &quot;file_name&quot;: &quot;NEON-SOAP-SJER-Vegetation-granule-list.txt&quot;, ## &quot;file_size&quot;: 11402, ## &quot;file_type&quot;: &quot;txt&quot; ## }, ## { ## &quot;sha256&quot;: &quot;6b824abc02ce3e49409e332e5b941533a66b2ff4c2a362b4d3b5b31b4266ecd5&quot;, ## &quot;file_id&quot;: &quot;16eae3d4-8876-403e-b673-2e29f2d8324a&quot;, ## &quot;file_name&quot;: &quot;NEON-SOAP-SJER-Vegetation-request.json&quot;, ## &quot;file_size&quot;: 883, ## &quot;file_type&quot;: &quot;json&quot; ## }, ## { ## &quot;sha256&quot;: &quot;3e025646ef6eadb42eb4d9f172db96ed824bbc72333519f0c8f44c3449fe4d7d&quot;, ## &quot;file_id&quot;: &quot;ff3f16d7-75c2-4185-8ce6-f6a3cc4de17c&quot;, ## &quot;file_name&quot;: &quot;NEON-SOAP-SJER-Vegetation-MCD15A3H-006-metadata.xml&quot;, ## &quot;file_size&quot;: 17255, ## &quot;file_type&quot;: &quot;xml&quot; ## }, ## { ## &quot;sha256&quot;: &quot;650cd511fcfc442fe675e35d14a244247c565085d5dcbb215782354d7ceda774&quot;, ## &quot;file_id&quot;: &quot;ffa0432e-cc7a-4cde-8264-6ad97dbed7c3&quot;, ## &quot;file_name&quot;: &quot;NEON-SOAP-SJER-Vegetation-MOD11A2-006-metadata.xml&quot;, ## &quot;file_size&quot;: 17217, ## &quot;file_type&quot;: &quot;xml&quot; ## }, ## { ## &quot;sha256&quot;: &quot;337cd424036258f85f9d216debfe1f9b0649bf2971ea1ce356a44b9c9ca51078&quot;, ## &quot;file_id&quot;: &quot;aa98b009-c955-468d-bd03-9ca7068969b9&quot;, ## &quot;file_name&quot;: &quot;README.md&quot;, ## &quot;file_size&quot;: 17894, ## &quot;file_type&quot;: &quot;txt&quot; ## } ## ], ## &quot;created&quot;: &quot;2020-10-07T21:38:39.407692&quot;, ## &quot;task_id&quot;: &quot;3a808dfa-ff0b-48f9-ac7b-9f598d73233b&quot;, ## &quot;updated&quot;: &quot;2020-10-07T21:39:07.732995&quot;, ## &quot;bundle_type&quot;: &quot;point&quot; ## } ## 6.17 Download Files in a Request (Automation) The bundle API provides information about completed tasks. For any completed task, a bundle can be queried to return the files contained as a part of the task request. Below, call the bundle API and return all of the output files. Next, read the contents of the bundle in JSON format and loop through file_id to automate downloading all of the output files into the output directory. For more information, please see AppEEARS API Documentation. bundle &lt;- fromJSON(bundle_response)$files for (id in bundle$file_id){ # retrieve the filename from the file_id filename &lt;- bundle[bundle$file_id == id,]$file_name # create a destination directory to store the file in filepath &lt;- paste(outDir,filename, sep = &quot;/&quot;) suppressWarnings(dir.create(dirname(filepath))) # write the file to disk using the destination directory and file name response &lt;- GET(paste0(API_URL, &quot;bundle/&quot;, task_id, &quot;/&quot;, id), write_disk(filepath, overwrite = TRUE), progress(), add_headers(Authorization = token)) } 6.18 Explore AppEEARS Quality Service The quality API provides quality details about all of the data products available in AppEEARS. Below are examples of how to query the quality API for listing quality products, layers, and values. The final example (Section 5c.) demonstrates how AppEEARS quality services can be leveraged to decode pertinent quality values for your data. For more information visit AppEEARS API documentation. First, reset pagination to include offset which allows you to set the number of results to skip before starting to return entries. Next, make a call to list all of the data product layers and the associated quality product and layer information. params &lt;- list(limit = 6, offset = 20, pretty = TRUE) # Set up the query parameters q_req &lt;- GET(paste0(API_URL, &quot;quality&quot;), query = params) # Request the quality info from quality API_URL q_content &lt;- content(q_req) # Retrieve the content of request q_response &lt;- toJSON(q_content, auto_unbox = TRUE) # Convert the info to JSON object remove(params, q_req, q_content) # Remove the variables that are not needed prettify(q_response) # Print the prettified quality information ## [ ## { ## &quot;ProductAndVersion&quot;: &quot;CU_LT05.001&quot;, ## &quot;Layer&quot;: &quot;SRB1&quot;, ## &quot;QualityProductAndVersion&quot;: &quot;CU_LT05.001&quot;, ## &quot;QualityLayers&quot;: [ ## &quot;PIXELQA&quot; ## ] ## }, ## { ## &quot;ProductAndVersion&quot;: &quot;CU_LT05.001&quot;, ## &quot;Layer&quot;: &quot;SRB2&quot;, ## &quot;QualityProductAndVersion&quot;: &quot;CU_LT05.001&quot;, ## &quot;QualityLayers&quot;: [ ## &quot;PIXELQA&quot; ## ] ## }, ## { ## &quot;ProductAndVersion&quot;: &quot;CU_LT05.001&quot;, ## &quot;Layer&quot;: &quot;SRB3&quot;, ## &quot;QualityProductAndVersion&quot;: &quot;CU_LT05.001&quot;, ## &quot;QualityLayers&quot;: [ ## &quot;PIXELQA&quot; ## ] ## }, ## { ## &quot;ProductAndVersion&quot;: &quot;CU_LT05.001&quot;, ## &quot;Layer&quot;: &quot;SRB4&quot;, ## &quot;QualityProductAndVersion&quot;: &quot;CU_LT05.001&quot;, ## &quot;QualityLayers&quot;: [ ## &quot;PIXELQA&quot; ## ] ## }, ## { ## &quot;ProductAndVersion&quot;: &quot;CU_LT05.001&quot;, ## &quot;Layer&quot;: &quot;SRB5&quot;, ## &quot;QualityProductAndVersion&quot;: &quot;CU_LT05.001&quot;, ## &quot;QualityLayers&quot;: [ ## &quot;PIXELQA&quot; ## ] ## }, ## { ## &quot;ProductAndVersion&quot;: &quot;CU_LT05.001&quot;, ## &quot;Layer&quot;: &quot;SRB7&quot;, ## &quot;QualityProductAndVersion&quot;: &quot;CU_LT05.001&quot;, ## &quot;QualityLayers&quot;: [ ## &quot;PIXELQA&quot; ## ] ## } ## ] ## 6.18.1 List Quality Layers This API call will list all of the quality layer information for a product. For more information visit AppEEARS API documentation productAndVersion &lt;- &#39;MCD15A3H.006&#39; # Assign ProductAndVersion to a variable # Request the quality info from quality API for a specific product MCD15A3H_req &lt;- GET(paste0(API_URL, &quot;quality/&quot;, productAndVersion)) MCD15A3H_content &lt;- content(MCD15A3H_req) # Retrieve the content of request MCD15A3H_quality &lt;- toJSON(MCD15A3H_content, auto_unbox = TRUE)# Convert the info to JSON object remove(MCD15A3H_req, MCD15A3H_content) # Remove the variables that are not needed anymore prettify(MCD15A3H_quality) # Print the prettified quality information ## [ ## { ## &quot;ProductAndVersion&quot;: &quot;MCD15A3H.006&quot;, ## &quot;Layer&quot;: &quot;Fpar_500m&quot;, ## &quot;QualityProductAndVersion&quot;: &quot;MCD15A3H.006&quot;, ## &quot;QualityLayers&quot;: [ ## &quot;FparLai_QC&quot;, ## &quot;FparExtra_QC&quot; ## ] ## }, ## { ## &quot;ProductAndVersion&quot;: &quot;MCD15A3H.006&quot;, ## &quot;Layer&quot;: &quot;FparStdDev_500m&quot;, ## &quot;QualityProductAndVersion&quot;: &quot;MCD15A3H.006&quot;, ## &quot;QualityLayers&quot;: [ ## &quot;FparLai_QC&quot;, ## &quot;FparExtra_QC&quot; ## ] ## }, ## { ## &quot;ProductAndVersion&quot;: &quot;MCD15A3H.006&quot;, ## &quot;Layer&quot;: &quot;Lai_500m&quot;, ## &quot;QualityProductAndVersion&quot;: &quot;MCD15A3H.006&quot;, ## &quot;QualityLayers&quot;: [ ## &quot;FparLai_QC&quot;, ## &quot;FparExtra_QC&quot; ## ] ## }, ## { ## &quot;ProductAndVersion&quot;: &quot;MCD15A3H.006&quot;, ## &quot;Layer&quot;: &quot;LaiStdDev_500m&quot;, ## &quot;QualityProductAndVersion&quot;: &quot;MCD15A3H.006&quot;, ## &quot;QualityLayers&quot;: [ ## &quot;FparLai_QC&quot;, ## &quot;FparExtra_QC&quot; ## ] ## } ## ] ## 6.18.2 Inspect Quality Values This API call will list all of the values for a given quality layer. quality_layer &lt;- &#39;FparLai_QC&#39; # assign a quality layer to a variable # Request the specified quality layer info from quality API quality_req &lt;- GET(paste0(API_URL, &quot;quality/&quot;, productAndVersion, &quot;/&quot;, quality_layer, sep = &quot;&quot;)) quality_content &lt;- content(quality_req) # Retrieve the content of request quality_response &lt;- toJSON(quality_content, auto_unbox = TRUE) # Convert the info to JSON object remove(quality_req, quality_content) # Remove the variables that are not needed prettify(quality_response) # Print the quality response as a data frame ## [ ## { ## &quot;ProductAndVersion&quot;: &quot;MCD15A3H.006&quot;, ## &quot;QualityLayer&quot;: &quot;FparLai_QC&quot;, ## &quot;Name&quot;: &quot;MODLAND&quot;, ## &quot;Value&quot;: 0, ## &quot;Description&quot;: &quot;Good quality (main algorithm with or without saturation)&quot;, ## &quot;Acceptable&quot;: true ## }, ## { ## &quot;ProductAndVersion&quot;: &quot;MCD15A3H.006&quot;, ## &quot;QualityLayer&quot;: &quot;FparLai_QC&quot;, ## &quot;Name&quot;: &quot;MODLAND&quot;, ## &quot;Value&quot;: 1, ## &quot;Description&quot;: &quot;Other Quality (back-up algorithm or fill values)&quot;, ## &quot;Acceptable&quot;: false ## }, ## { ## &quot;ProductAndVersion&quot;: &quot;MCD15A3H.006&quot;, ## &quot;QualityLayer&quot;: &quot;FparLai_QC&quot;, ## &quot;Name&quot;: &quot;Sensor&quot;, ## &quot;Value&quot;: 0, ## &quot;Description&quot;: &quot;Terra&quot;, ## &quot;Acceptable&quot;: { ## ## } ## }, ## { ## &quot;ProductAndVersion&quot;: &quot;MCD15A3H.006&quot;, ## &quot;QualityLayer&quot;: &quot;FparLai_QC&quot;, ## &quot;Name&quot;: &quot;Sensor&quot;, ## &quot;Value&quot;: 1, ## &quot;Description&quot;: &quot;Aqua&quot;, ## &quot;Acceptable&quot;: { ## ## } ## }, ## { ## &quot;ProductAndVersion&quot;: &quot;MCD15A3H.006&quot;, ## &quot;QualityLayer&quot;: &quot;FparLai_QC&quot;, ## &quot;Name&quot;: &quot;DeadDetector&quot;, ## &quot;Value&quot;: 0, ## &quot;Description&quot;: &quot;Detectors apparently fine for up to 50% of channels 1, 2&quot;, ## &quot;Acceptable&quot;: { ## ## } ## }, ## { ## &quot;ProductAndVersion&quot;: &quot;MCD15A3H.006&quot;, ## &quot;QualityLayer&quot;: &quot;FparLai_QC&quot;, ## &quot;Name&quot;: &quot;DeadDetector&quot;, ## &quot;Value&quot;: 1, ## &quot;Description&quot;: &quot;Dead detectors caused &gt;50% adjacent detector retrieval&quot;, ## &quot;Acceptable&quot;: { ## ## } ## }, ## { ## &quot;ProductAndVersion&quot;: &quot;MCD15A3H.006&quot;, ## &quot;QualityLayer&quot;: &quot;FparLai_QC&quot;, ## &quot;Name&quot;: &quot;CloudState&quot;, ## &quot;Value&quot;: 0, ## &quot;Description&quot;: &quot;Significant clouds NOT present (clear)&quot;, ## &quot;Acceptable&quot;: { ## ## } ## }, ## { ## &quot;ProductAndVersion&quot;: &quot;MCD15A3H.006&quot;, ## &quot;QualityLayer&quot;: &quot;FparLai_QC&quot;, ## &quot;Name&quot;: &quot;CloudState&quot;, ## &quot;Value&quot;: 1, ## &quot;Description&quot;: &quot;Significant clouds WERE present&quot;, ## &quot;Acceptable&quot;: { ## ## } ## }, ## { ## &quot;ProductAndVersion&quot;: &quot;MCD15A3H.006&quot;, ## &quot;QualityLayer&quot;: &quot;FparLai_QC&quot;, ## &quot;Name&quot;: &quot;CloudState&quot;, ## &quot;Value&quot;: 2, ## &quot;Description&quot;: &quot;Mixed cloud present in pixel&quot;, ## &quot;Acceptable&quot;: { ## ## } ## }, ## { ## &quot;ProductAndVersion&quot;: &quot;MCD15A3H.006&quot;, ## &quot;QualityLayer&quot;: &quot;FparLai_QC&quot;, ## &quot;Name&quot;: &quot;CloudState&quot;, ## &quot;Value&quot;: 3, ## &quot;Description&quot;: &quot;Cloud state not defined, assumed clear&quot;, ## &quot;Acceptable&quot;: { ## ## } ## }, ## { ## &quot;ProductAndVersion&quot;: &quot;MCD15A3H.006&quot;, ## &quot;QualityLayer&quot;: &quot;FparLai_QC&quot;, ## &quot;Name&quot;: &quot;SCF_QC&quot;, ## &quot;Value&quot;: 0, ## &quot;Description&quot;: &quot;Main (RT) method used, best result possible (no saturation)&quot;, ## &quot;Acceptable&quot;: { ## ## } ## }, ## { ## &quot;ProductAndVersion&quot;: &quot;MCD15A3H.006&quot;, ## &quot;QualityLayer&quot;: &quot;FparLai_QC&quot;, ## &quot;Name&quot;: &quot;SCF_QC&quot;, ## &quot;Value&quot;: 1, ## &quot;Description&quot;: &quot;Main (RT) method used with saturation. Good, very usable&quot;, ## &quot;Acceptable&quot;: { ## ## } ## }, ## { ## &quot;ProductAndVersion&quot;: &quot;MCD15A3H.006&quot;, ## &quot;QualityLayer&quot;: &quot;FparLai_QC&quot;, ## &quot;Name&quot;: &quot;SCF_QC&quot;, ## &quot;Value&quot;: 2, ## &quot;Description&quot;: &quot;Main (RT) method failed due to bad geometry, empirical algorithm used&quot;, ## &quot;Acceptable&quot;: { ## ## } ## }, ## { ## &quot;ProductAndVersion&quot;: &quot;MCD15A3H.006&quot;, ## &quot;QualityLayer&quot;: &quot;FparLai_QC&quot;, ## &quot;Name&quot;: &quot;SCF_QC&quot;, ## &quot;Value&quot;: 3, ## &quot;Description&quot;: &quot;Main (RT) method failed due to problems other than geometry, empirical algorithm used&quot;, ## &quot;Acceptable&quot;: { ## ## } ## }, ## { ## &quot;ProductAndVersion&quot;: &quot;MCD15A3H.006&quot;, ## &quot;QualityLayer&quot;: &quot;FparLai_QC&quot;, ## &quot;Name&quot;: &quot;SCF_QC&quot;, ## &quot;Value&quot;: 4, ## &quot;Description&quot;: &quot;Pixel not produced at all, value couldn&#39;t be retrieved (possible reasons: bad L1B data, unusable MOD09GA data)&quot;, ## &quot;Acceptable&quot;: { ## ## } ## } ## ] ## 6.19 Decode Quality Values This API call will decode the bits for a given quality value. quality_value &lt;- 1 # Assign a quality value to a variable # Request and retrieve information for provided quality value from quality API URL response &lt;- content(GET(paste0(API_URL, &quot;quality/&quot;, productAndVersion, &quot;/&quot;, quality_layer, &quot;/&quot;, quality_value))) q_response &lt;- toJSON(response, auto_unbox = TRUE) # Convert the info to JSON object remove(response) # Remove the variables that are not needed anymore prettify(q_response) # Print the prettified response ## { ## &quot;Binary Representation&quot;: &quot;0b00000001&quot;, ## &quot;MODLAND&quot;: { ## &quot;bits&quot;: &quot;0b1&quot;, ## &quot;description&quot;: &quot;Other Quality (back-up algorithm or fill values)&quot; ## }, ## &quot;Sensor&quot;: { ## &quot;bits&quot;: &quot;0b0&quot;, ## &quot;description&quot;: &quot;Terra&quot; ## }, ## &quot;DeadDetector&quot;: { ## &quot;bits&quot;: &quot;0b0&quot;, ## &quot;description&quot;: &quot;Detectors apparently fine for up to 50% of channels 1, 2&quot; ## }, ## &quot;CloudState&quot;: { ## &quot;bits&quot;: &quot;0b00&quot;, ## &quot;description&quot;: &quot;Significant clouds NOT present (clear)&quot; ## }, ## &quot;SCF_QC&quot;: { ## &quot;bits&quot;: &quot;0b000&quot;, ## &quot;description&quot;: &quot;Main (RT) method used, best result possible (no saturation)&quot; ## } ## } ## 6.20 Load Request Output and Visualize Here, load the CSV file containing the results from your request using readr package, and create some basic visualizations using the ggplot2 package. 6.21 Load a CSV Use the readr package to load the CSV file containing the results from the AppEEARS request. # Make a list of csv files in the output directory files &lt;- list.files(outDir, pattern = &quot;\\\\MOD11A2-006-results.csv$&quot;) # Read the MOD11A2 results df &lt;- read_csv(paste0(outDir,&quot;/&quot;, files)) Select the MOD11A2.006 LST Day column for the data from Grand Canyon National Park using dplyr package. lst_GC &lt;- df %&gt;% # Filter df for the point from GC filter(Category == &quot;SOAP&quot;) %&gt;% # Select desired columns select(Latitude, Longitude, Date ,MOD11A2_006_LST_Day_1km, MOD11A2_006_LST_Night_1km) Extract information for LST_DAY_1KM from MOD11_response of product service call from earlier in the tutorial. #fromJSON(MOD11_response)$LST_Day_1km # Extract all the info for LST_Day_1km layer fillValue &lt;- fromJSON(MOD11_response)$LST_Day_1km$FillValue # Assign fill value to a variable unit &lt;- fromJSON(MOD11_response)$LST_Day_1km$Units # Assign unit to a variable sprintf(&quot;Fill value for LST_DAY_1KM is: %i&quot; ,fillValue) # Print LST_DAY_1KM fill value ## [1] &quot;Fill value for LST_DAY_1KM is: 0&quot; sprintf(&quot;Unit for LST_DAY_1KM is: %s&quot; ,unit) # Print LST_DAY_1KM unit ## [1] &quot;Unit for LST_DAY_1KM is: Kelvin&quot; 6.22 Plot Results (Line/Scatter Plots) Next, plot a time series of daytime LST for the selected point in Grand Canyon National Park for 2018. Below, filter the LST data to exclude fill values. lst_GC &lt;- lst_GC %&gt;% # exclude NoData filter(MOD11A2_006_LST_Day_1km != fillValue)%&gt;% filter(MOD11A2_006_LST_Night_1km != fillValue) Next, plot LST Day as a time series with some additional formatting using ggplot2. ggplot(lst_GC)+ geom_line(aes(x= Date, y = MOD11A2_006_LST_Day_1km), size=1, color=&quot;blue&quot;)+ geom_point(aes(x= Date, y = MOD11A2_006_LST_Day_1km), shape=18 , size = 3, color=&quot;blue&quot;)+ labs(title = &quot;Time Series&quot;, x = &quot;Date&quot;, y = sprintf( &quot;LST_Day_1km (%s)&quot;, unit))+ scale_x_date(date_breaks = &quot;16 day&quot;)+ scale_y_continuous(limits = c(250, 325), breaks = seq(250, 325, 10))+ theme(plot.title = element_text(face = &quot;bold&quot;,size = rel(2.5),hjust = 0.5), axis.title = element_text(face = &quot;bold&quot;,size = rel(1)), panel.background = element_rect(fill = &quot;lightgray&quot;, colour = &quot;black&quot;), axis.text.x = element_text(face =&quot;bold&quot;,color=&quot;black&quot;, angle= 315 , size = 10), axis.text.y = element_text(face =&quot;bold&quot;,color=&quot;black&quot;, angle= 0, size = 10) ) Using the tidyr package, the LST Day and Night values for Grand Canyon NP are being gathered in a single column to be used to make a plot including both LST_Day_1km and LST_Night_1km. lst_GC_DN &lt;- tidyr::gather(lst_GC, key = Tstat , value = LST, MOD11A2_006_LST_Day_1km, MOD11A2_006_LST_Night_1km) lst_GC_DN[1:5,] # print the five first observations ## # A tibble: 5 x 5 ## Latitude Longitude Date Tstat LST ## &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 37.0 -119. 2019-12-27 MOD11A2_006_LST_Day_1km 278. ## 2 37.0 -119. 2020-01-01 MOD11A2_006_LST_Day_1km 283. ## 3 37.0 -119. 2020-01-09 MOD11A2_006_LST_Day_1km 280. ## 4 37.0 -119. 2020-01-17 MOD11A2_006_LST_Day_1km 283. ## 5 37.0 -119. 2020-01-25 MOD11A2_006_LST_Day_1km 285. Next, plot LST Day and Night as a time series with some additional formatting. ggplot(lst_GC_DN)+ geom_line(aes(x= Date, y = LST, color = Tstat), size=1)+ geom_point(aes(x= Date, y = LST, color = Tstat), shape=18 , size = 3)+ scale_fill_manual(values=c(&quot;red&quot;, &quot;blue&quot;))+ scale_color_manual(values=c(&#39;red&#39;,&#39;blue&#39;))+ labs(title = &quot;Time Series&quot;, x = &quot;Date&quot;, y = sprintf( &quot;LST_Day_1km (%s)&quot;,unit))+ scale_x_date(date_breaks = &quot;16 day&quot;)+ scale_y_continuous(limits = c(250, 325), breaks = seq(250, 325, 10))+ theme(plot.title = element_text(face = &quot;bold&quot;,size = rel(2.5), hjust = 0.5), axis.title = element_text(face = &quot;bold&quot;,size = rel(1)), panel.background = element_rect(fill = &quot;lightgray&quot;, colour = &quot;black&quot;), axis.text.x = element_text(face =&quot;bold&quot;,color=&quot;black&quot;, angle= 315 , size = 10), axis.text.y = element_text(face =&quot;bold&quot;,color=&quot;black&quot;, angle= 0, size = 10), legend.position = &quot;bottom&quot;, legend.title = element_blank() ) Finally, bring in the daytime LST data from SJER , and compare with daytime LST at SOAP , shown below in a scatterplot using ggplot2 package. Here, the dplyr is used to extract the LST_DAY_1km for Zion National Park. lst_Z &lt;- df %&gt;% filter(MOD11A2_006_LST_Day_1km != fillValue) %&gt;% # Filter fill value filter(Category == &quot;SJER&quot;)%&gt;% # Filter Zion national park select(Date, MOD11A2_006_LST_Day_1km) # Select desired columns Make a scatterplot. ggplot()+ geom_point(aes(x=lst_Z$MOD11A2_006_LST_Day_1km, y=lst_GC$MOD11A2_006_LST_Day_1km), shape=18 , size = 3, color=&quot;blue&quot;)+ labs(title = &quot;MODIS LST: SOAP vs. SJER, 2020&quot;, x = sprintf(&quot;SOAP: LST_Day_1km (%s)&quot;,unit), y = sprintf( &quot;SJER: LST_Day_1km (%s)&quot;,unit))+ theme(plot.title = element_text(face = &quot;bold&quot;,size = rel(1.5), hjust = 0.5), axis.title = element_text(face = &quot;bold&quot;,size = rel(1)), panel.background = element_rect(fill = &quot;lightgray&quot;, colour = &quot;black&quot;), axis.text.x = element_text(face =&quot;bold&quot;,color=&quot;black&quot;, size = 10), axis.text.y = element_text(face =&quot;bold&quot;,color=&quot;black&quot;, size = 10) ) This example can provide a template to use for your own research workflows. Leveraging the AppEEARS API for searching, extracting, and formatting analysis ready data, and loading it directly into R means that you can keep your entire research workflow in a single software program, from start to finish. 6.23 Submit an Area Request 6.24 NASA EOS Written Questions How does the scientific method of Earth Science differ from thta of traditional/classical labratory sciences? 6.25 NASA EOS Culmination Write Up Write up a 1-page derived data product or research pipeline proposal summary of a project that you might want to explore using NASA EOS data. Include the types of data that you would need to implement this project and how you would retrieve them. Save this summary as you will be refining and adding to your ideas over the course of the semester. Suggestions: Tables or bullet lists of specific data products An overarching high-quality figure to show how these data align One paragraph summarizing how this data or analysis is useful to you and/or the infrastructure. "]
]
